<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹏少的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-16T02:04:36.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鹏少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring相关问题</title>
    <link href="http://example.com/2024/05/16/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/05/16/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-16T02:04:36.000Z</published>
    <updated>2024-05-16T02:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Bean的scope（作用域）有哪些"><a href="#Spring-Bean的scope（作用域）有哪些" class="headerlink" title="Spring Bean的scope（作用域）有哪些"></a>Spring Bean的scope（作用域）有哪些</h3><p>Bean 的 scope（作用域）定义了 Bean 实例的生命周期及可见范围，常见的 Bean scope：</p><p>*<strong>Singleton（单例）</strong>：在整个应用程序中只存在一个 Bean 实例。默认作用域，Spring 容器中只会创建一个 Bean 实例，并在容器的整个生命周期中共享该实例。</p><p>*<strong>Prototype（原型）</strong>：每次请求时都会创建一个新的 Bean 实例。次从容器中获取该 Bean 时都会创建一个新实例，适用于状态非常瞬时的 Bean。</p><p>*<strong>Request（请求）</strong>：每个 HTTP 请求都会创建一个新的 Bean 实例。仅在 Spring Web 应用程序中有效，每个 HTTP 请求都会创建一个新的 Bean 实例，适用于 Web 应用中需求局部性的 Bean。</p><p>*<strong>Session（会话）</strong>：Session 范围内只会创建一个 Bean 实例。该 Bean 实例在用户会话范围内共享，仅在 Spring Web 应用程序中有效，适用于与用户会话相关的 Bean。</p><p>*<strong>Application</strong>：当前 ServletContext 中只存在一个 Bean 实例。仅在 Spring Web 应用程序中有效，该 Bean 实例在整个 ServletContext 范围内共享，适用于应用程序范围内共享的 Bean。</p><p>*<strong>WebSocket（Web套接字）</strong>：在 WebSocket 范围内只存在一个 Bean 实例。仅在支持 WebSocket 的应用程序中有效，该 Bean 实例在 WebSocket 会话范围内共享，适用于 WebSocket 会话范围内共享的 Bean。</p><p>*<strong>Custom scopes（自定义作用域）</strong>：Spring 允许开发者定义自定义的作用域，通过实现 Scope 接口来创建新的 Bean 作用域。</p><h3 id="讲一讲AOP的实现方式"><a href="#讲一讲AOP的实现方式" class="headerlink" title="讲一讲AOP的实现方式"></a>讲一讲AOP的实现方式</h3><p>Spring的AOP实现原理其实很简单，就是通过动态代理实现的。如果我们为Spring的某个bean配置了切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。而Spring的AOP使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。</p><p>*<strong>基于JDK的动态代理</strong>：Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理。熟悉Java语言的应该会对JDK动态代理有所了解。JDK实现动态代理需要两个组件，首先第一个就是InvocationHandler接口。我们在使用JDK的动态代理时，需要编写一个类，去实现这个接口，然后重写invoke方法，这个方法其实就是我们提供的代理方法。然后JDK动态代理需要使用的第二个组件就是Proxy这个类，我们可以通过这个类的newProxyInstance方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的invoke方法。</p><p>*<strong>基于CGLIB的动态代理</strong>：JDK的动态代理存在限制，那就是被代理的类必须是一个实现了接口的类，代理类需要实现相同的接口，代理接口中声明的方法。若需要代理的类没有实现接口，此时JDK的动态代理将没有办法使用，于是Spring会使用CGLib的动态代理来生成代理对象。CGLib直接操作字节码，生成类的子类，重写类的方法完成代理。</p><h3 id="JDK-Proxy和CGLib还有别的实现AOP的方式吗？"><a href="#JDK-Proxy和CGLib还有别的实现AOP的方式吗？" class="headerlink" title="JDK Proxy和CGLib还有别的实现AOP的方式吗？"></a>JDK Proxy和CGLib还有别的实现AOP的方式吗？</h3><p><strong>静态代理</strong>：通过 AOP 框架提供的命令进行编译，从而在编译阶段生成 AOP 代理类。这种方式也被称为编译时增强。静态代理包括编译时编织和类加载时编织两种方式。</p><h3 id="讲一讲对Spring-Boot的理解，以及为什么要用Spring-Boot？"><a href="#讲一讲对Spring-Boot的理解，以及为什么要用Spring-Boot？" class="headerlink" title="讲一讲对Spring Boot的理解，以及为什么要用Spring Boot？"></a>讲一讲对Spring Boot的理解，以及为什么要用Spring Boot？</h3><p>在使用Spring框架进行开发的过程中，需要配置很多Spring框架包的依赖，如spring-core、spring-bean、spring-context等，而这些配置通常都是重复添加的，而且需要做很多框架使用及环境参数的重复配置，如开启注解、配置日志等。</p><p>Spring Boot致力于弱化这些不必要的操作，提供默认配置，当然这些默认配置是可以按需修改的，快速搭建、开发和运行Spring应用。</p><p>Spring Boot 的主要优点：</p><p> *<strong>简化开发</strong>：Spring Boot通过约定大于配置的原则和自动化配置，大大简化了Java应用程序的开发和部署过程。开发者无需处理繁琐的配置，可以快速搭建项目并专注于业务逻辑的实现。</p><p>*<strong>集成性强</strong>：Spring Boot提供了大量的起步依赖，涵盖了各种常见的库、框架和组件，使得集成第三方库和服务变得更加容易。同时，Spring Boot内置了大量的功能，如内置容器、安全性、监控等，可以快速集成这些功能到项目中。</p><p>*<strong>独立运行</strong>：Spring Boot应用程序可以独立运行，内嵌了常用的Web服务器，如Tomcat、Jetty等，使得部署变得简单。开发者无需额外配置Web服务器，只需执行一个可执行的JAR文件即可启动应用。</p><p>*<strong>微服务友好</strong>：Spring Boot非常适合构建微服务架构，其轻量级、模块化的特性使得微服务之间的通信和部署变得更加方便。结合Spring Cloud等微服务组件，可以更好地实现微服务架构下的各种功能。</p><h3 id="讲一讲Spring-Boot简化配置具体是如何简化的？"><a href="#讲一讲Spring-Boot简化配置具体是如何简化的？" class="headerlink" title="讲一讲Spring Boot简化配置具体是如何简化的？"></a>讲一讲Spring Boot简化配置具体是如何简化的？</h3><p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。</p><p>举个例子：我新建一个类，但是我不用 @Service注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean两个注解即可，如下：</p><pre><code>public class TestService &#123;    public String sayHello () &#123;        return &quot;Hello Spring Boot!&quot;;    &#125;&#125;</code></pre><p>1</p><pre><code>import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class JavaConfig &#123;    @Bean    public TestService getTestService() &#123;        return new TestService();    &#125;&#125;</code></pre><p>@Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource注解注入进来即可使用，非常方便。</p><pre><code>@Resourceprivate TestService testService;</code></pre><p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p><h3 id="Spring-Boot是通过什么实现的约定大于配置？"><a href="#Spring-Boot是通过什么实现的约定大于配置？" class="headerlink" title="Spring Boot是通过什么实现的约定大于配置？"></a>Spring Boot是通过什么实现的约定大于配置？</h3><p>Spring Boot通过「自动化配置」和「起步依赖」实现了约定大于配置的特性。</p><p>*自动化配置：Spring Boot根据项目的依赖和环境自动配置应用程序，无需手动配置大量的XML或Java配置文件。例如，如果项目引入了Spring Web MVC依赖，Spring Boot会自动配置一个基本的Web应用程序上下文。</p><p>*起步依赖：Spring Boot提供了一系列起步依赖，这些依赖包含了常用的框架和功能，可以帮助开发者快速搭建项目。通过引入适合项目需求的起步依赖，开发者可以快速构建出符合要求的应用程序，减少了配置的复杂度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-Bean的scope（作用域）有哪些&quot;&gt;&lt;a href=&quot;#Spring-Bean的scope（作用域）有哪些&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean的scope（作用域）有哪些&quot;&gt;&lt;/a&gt;Spring Bean</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2024/05/15/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/05/15/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-15T02:28:31.000Z</published>
    <updated>2024-05-15T02:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>*BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</p><p>*NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p><p>*AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><h3 id="有哪个框架用到NIO"><a href="#有哪个框架用到NIO" class="headerlink" title="有哪个框架用到NIO"></a>有哪个框架用到NIO</h3><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p><p><img src="/assets/imgs/2024-05-15_102831.png" alt="NIO"></p><p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。</p><h3 id="讲一讲String、StringBuffer和StringBuilder的区别"><a href="#讲一讲String、StringBuffer和StringBuilder的区别" class="headerlink" title="讲一讲String、StringBuffer和StringBuilder的区别"></a>讲一讲String、StringBuffer和StringBuilder的区别</h3><p><strong>区别</strong>：</p><p>*String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</p><p>*StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</p><p>*StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</p><p><strong>线程安全</strong>：</p><p>*StringBuffer：线程安全</p><p>*StringBuilder：线程不安全</p><p><strong>速度</strong>： 一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</p><p><strong>使用场景</strong>：</p><p>*操作少量的数据使用 String。</p><p>*单线程操作大量数据使用 StringBuilder。</p><p>*多线程操作大量数据使用 StringBuffer。</p><h3 id="讲一讲Java注解的原理"><a href="#讲一讲Java注解的原理" class="headerlink" title="讲一讲Java注解的原理"></a>讲一讲Java注解的原理</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h3 id="Java注解的作用域"><a href="#Java注解的作用域" class="headerlink" title="Java注解的作用域"></a>Java注解的作用域</h3><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p><p>1、类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</p><p>2、方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</p><p>3、字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</p><p>除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h3&gt;&lt;p&gt;*BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="http://example.com/2024/05/14/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/05/14/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2024-05-14T06:45:17.000Z</published>
    <updated>2024-05-14T06:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有哪些解决线程并发问题的方案？"><a href="#有哪些解决线程并发问题的方案？" class="headerlink" title="有哪些解决线程并发问题的方案？"></a>有哪些解决线程并发问题的方案？</h3><p>*当只有一个线程写，其它线程都是读的时候，可以用volatile修饰变量</p><p>*当多个线程写，那么一般情况下并发不严重的话可以用Synchronized，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。ReentranLock 可以通过代码释放锁，可以设置锁超时。</p><p>*高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如ConcurrentHashMap，LinkBlockingQueue，以及原子性的数据结构如：AtomicInteger。</p><h3 id="悲观锁和乐观锁的区别。"><a href="#悲观锁和乐观锁的区别。" class="headerlink" title="悲观锁和乐观锁的区别。"></a>悲观锁和乐观锁的区别。</h3><p>*乐观锁：乐观锁假设多个事务之间很少发生冲突，因此在读取数据时不会加锁，而是在更新数据时检查数据的版本（如使用版本号或时间戳），如果版本匹配则执行更新操作，否则认为发生了冲突。</p><p>*悲观锁：悲观锁假设多个事务之间会频繁发生冲突，因此在读取数据时会加锁，防止其他事务对数据进行修改，直到当前事务完成操作后才释放锁。</p><h3 id="悲观锁和乐观锁使用场景的差别是什么？"><a href="#悲观锁和乐观锁使用场景的差别是什么？" class="headerlink" title="悲观锁和乐观锁使用场景的差别是什么？"></a>悲观锁和乐观锁使用场景的差别是什么？</h3><p>*乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>*悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h3 id="Java中想实现一个乐观锁，都有哪些方式？"><a href="#Java中想实现一个乐观锁，都有哪些方式？" class="headerlink" title="Java中想实现一个乐观锁，都有哪些方式？"></a>Java中想实现一个乐观锁，都有哪些方式？</h3><p>*CAS（Compare and Swap）操作： CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。</p><p>*版本号控制：增加一个版本号字段记录数据更新时候的版本，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。</p><p>*时间戳：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。</p><h3 id="使用时间戳会不会有可见性问题？"><a href="#使用时间戳会不会有可见性问题？" class="headerlink" title="使用时间戳会不会有可见性问题？"></a>使用时间戳会不会有可见性问题？</h3><p>会有可见性的问题，可见性问题指的是当一个线程修改了共享变量的值后，其他线程可能无法立即看到这个变化。</p><p>如果一个线程在读取数据的时间戳之后，另一个线程修改了数据并更新了时间戳，第一个线程可能无法感知到第二个线程的修改。这导致第一个线程在接下来的操作中基于过时的时间戳做出了错误的判断，从而可能发生数据不一致的情况。</p><p>为了避免时间戳导致的可见性问题，可以考虑使用<strong>volatile关键字</strong>： 在时间戳字段上使用 volatile 关键字可以确保多线程之间的可见性，可以及时看到其他线程对共享变量的修改。</p><h3 id="volatile能解决吗，就够了吗？"><a href="#volatile能解决吗，就够了吗？" class="headerlink" title="volatile能解决吗，就够了吗？"></a>volatile能解决吗，就够了吗？</h3><p>volatile 关键字仅仅保证了可见性，并没有提供原子性。在实现乐观锁时，如果仅仅依赖 volatile 关键字来保证时间戳的可见性，仍然可能面临以下问题：</p><p><strong>复合操作可能存在问题</strong>： 如果对时间戳字段的更新是一个复合操作，如读取时间戳、计算新值、更新时间戳，这样的操作并不具备原子性。在这种情况下，仅仅使用 volatile 是无法保证操作的原子性和线程安全的。</p><p>可以通过加锁的方式来保证对时间戳读写操作的并发安全。</p><h3 id="除了加锁还有没有别的解法，绕开加锁使性能更好？"><a href="#除了加锁还有没有别的解法，绕开加锁使性能更好？" class="headerlink" title="除了加锁还有没有别的解法，绕开加锁使性能更好？"></a>除了加锁还有没有别的解法，绕开加锁使性能更好？</h3><p>可以改用 Atomic 类来保证原子性，这些原子类是使用 CAS (Compare and Swap) 操作来保证数据的原子性。如 AtomicInteger、AtomicLong、AtomicReference 等，通过这些原子类可以实现 CAS 操作，从而确保对共享变量的原子操作。</p><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：</p><pre><code>*ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁*ReentrantLock 可以获取各种锁的信息*ReentrantLock 可以灵活地实现多路通知</code></pre><h3 id="讲一讲ThreadLocal使用的时候需要注意哪些点。"><a href="#讲一讲ThreadLocal使用的时候需要注意哪些点。" class="headerlink" title="讲一讲ThreadLocal使用的时候需要注意哪些点。"></a>讲一讲ThreadLocal使用的时候需要注意哪些点。</h3><p>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</p><pre><code>*set 给ThreadLocalMap设置值。*get 获取ThreadLocalMap。*remove 删除ThreadLocalMap类型的对象。</code></pre><p>存在的问题:</p><pre><code>1、对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。2、内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。</code></pre><p>使用完ThreadLocal后，及时调用remove()方法释放内存空间，这样就能避免内存泄漏。</p><h3 id="线程并发还有别的问题吗？"><a href="#线程并发还有别的问题吗？" class="headerlink" title="线程并发还有别的问题吗？"></a>线程并发还有别的问题吗？</h3><p>Java的线程安全在三个方面体现</p><p>*<strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic和synchronized这两个关键字来确保原子性；</p><p>*<strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</p><p>*<strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</p><h3 id="常用的线程池有哪些呢？"><a href="#常用的线程池有哪些呢？" class="headerlink" title="常用的线程池有哪些呢？"></a>常用的线程池有哪些呢？</h3><p>*ScheduledThreadPool：可以设置定期的执行任务，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。</p><p>*FixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p><p>*CachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p><p>*SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p><p>*SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。</p><h3 id="简单讲一讲线程的生命周期"><a href="#简单讲一讲线程的生命周期" class="headerlink" title="简单讲一讲线程的生命周期"></a>简单讲一讲线程的生命周期</h3><p><img src="/assets/imgs/2024-05-14_144517.jpg" alt="ThreadPool"><br>线程池的五个状态如下</p><p>*RUNNING: 接收新的任务，并能继续处理 workQueue 中的任务</p><p>*SHUTDOWN: 不再接收新的任务，不过能继续处理 workQueue 中的任务</p><p>*STOP: 不再接收新的任务，也不再处理 workQueue 中的任务，并且会中断正在处理任务的线程</p><p>*TIDYING: 所有的任务都完结了，并且线程数量（workCount）为 0 时即为此状态，进入此状态后会调用 terminated() 这个钩子方法进入 TERMINATED 状态</p><p>*TERMINATED: 调用 terminated() 方法后即为此状态</p><h3 id="有什么办法能够提升Java线程的并发能力呢？"><a href="#有什么办法能够提升Java线程的并发能力呢？" class="headerlink" title="有什么办法能够提升Java线程的并发能力呢？"></a>有什么办法能够提升Java线程的并发能力呢？</h3><p>*<strong>使用线程池</strong>：合理配置线程池大小，避免频繁创建和销毁线程，提高线程的复用率，减少资源开销。</p><p>*<strong>使用并发集合</strong>：Java 并发包中提供了诸如 ConcurrentHashMap、ConcurrentLinkedQueue 等线程安全的集合类，使用这些并发集合可以减少在多线程环境下的锁竞争，提升并发性能</p><p>*<strong>避免锁粒度过细</strong>：过细的锁粒度会增加锁的竞争，影响并发性能，尽量使用合适的锁粒度来避免锁的争用。</p><p>*<strong>减少同步区域代码量</strong>：在同步代码块中尽量减少耗时操作，保持同步区域的代码量尽量少，以减少线程等待时间，提高并发性能。</p><p>*<strong>使用乐观锁</strong>：乐观锁机制可以提高并发性能，通过版本号或时间戳等方式，避免使用传统的悲观锁机制，减少不必要的阻塞。</p><p>*<strong>使用无锁算法</strong>：无锁的数据结构和算法可以减少锁的开销和线程之间的竞争，如CAS操作、原子类等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有哪些解决线程并发问题的方案？&quot;&gt;&lt;a href=&quot;#有哪些解决线程并发问题的方案？&quot; class=&quot;headerlink&quot; title=&quot;有哪些解决线程并发问题的方案？&quot;&gt;&lt;/a&gt;有哪些解决线程并发问题的方案？&lt;/h3&gt;&lt;p&gt;*当只有一个线程写，其它线程都是读的</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java并发" scheme="http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识点</title>
    <link href="http://example.com/2024/05/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://example.com/2024/05/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2024-05-13T07:06:15.000Z</published>
    <updated>2024-05-13T07:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM的内存区域和作用"><a href="#JVM的内存区域和作用" class="headerlink" title="JVM的内存区域和作用"></a>JVM的内存区域和作用</h3><p>JVM运行时内存共分为<strong>虚拟机栈、堆、元空间、程序计数器、本地方法栈</strong>五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><p><img src="/assets/imgs/2024-05-13_150615.jpg" alt="JVM"></p><p>JVM的内存结构主要分为以下几个部分：</p><p>*元空间：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p>*Java虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。</p><p>*本地方法栈：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</p><p>*程序计数器：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</p><p>*堆内存：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。</p><p>*直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I&#x2F;O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h3 id="常见的GC算法有哪些？"><a href="#常见的GC算法有哪些？" class="headerlink" title="常见的GC算法有哪些？"></a>常见的GC算法有哪些？</h3><p>Java的内存回收机制基于自动内存管理，开发人员无需手动释放内存。垃圾回收器会自动识别不再使用的对象，并回收它们所占用的内存空间。垃圾回收算法主要有 ：</p><p>*标记-清除算法：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</p><p>*复制算法：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</p><p>*标记-整理算法：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</p><p>*分代回收算法：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</p><h3 id="JVM中有哪些回收器？"><a href="#JVM中有哪些回收器？" class="headerlink" title="JVM中有哪些回收器？"></a>JVM中有哪些回收器？</h3><p>*Serial 收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</p><p>*ParNew 收集器，ParNew 收集器其实就是 Serial 收集器的多线程版本。</p><p>*Parallel 收集器，Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。</p><p>*Parallel Old 收集器，Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和”标记－整理”算法</p><p>*CMS 收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>*G1 收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</p><h3 id="G1回收器的特色是什么？"><a href="#G1回收器的特色是什么？" class="headerlink" title="G1回收器的特色是什么？"></a>G1回收器的特色是什么？</h3><p>G1 的特点：</p><pre><code>*G1最大的特点是引入分区的思路，弱化了分代的概念。*合理利用垃圾收集各个周期的资源，解决了其他收集器、甚至 CMS 的众多缺陷</code></pre><p>G1 相比较 CMS 的改进：</p><pre><code>*算法：G1 基于标记--整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。*停顿时间可控：G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。*并行与并发：G1 能更充分的利用 CPU 多核环境下的硬件优势，来缩短 stop the world 的停顿时间。</code></pre><h3 id="GC只会对堆进行GC吗？"><a href="#GC只会对堆进行GC吗？" class="headerlink" title="GC只会对堆进行GC吗？"></a>GC只会对堆进行GC吗？</h3><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p><p>*堆（Heap）： 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。<br>*方法区（Method Area）： 方法区是用于存储类信息、常量、静态变量等数据的区域。虽然方法区中的垃圾回收与堆有所不同，但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JVM的内存区域和作用&quot;&gt;&lt;a href=&quot;#JVM的内存区域和作用&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存区域和作用&quot;&gt;&lt;/a&gt;JVM的内存区域和作用&lt;/h3&gt;&lt;p&gt;JVM运行时内存共分为&lt;strong&gt;虚拟机栈、堆、元空间、程序计数</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java虚拟机" scheme="http://example.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
