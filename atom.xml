<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹏少的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-14T07:23:20.283Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鹏少</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发</title>
    <link href="http://example.com/2024/05/14/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2024/05/14/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2024-05-14T06:45:17.000Z</published>
    <updated>2024-05-14T07:23:20.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有哪些解决线程并发问题的方案？"><a href="#有哪些解决线程并发问题的方案？" class="headerlink" title="有哪些解决线程并发问题的方案？"></a>有哪些解决线程并发问题的方案？</h3><p>*当只有一个线程写，其它线程都是读的时候，可以用volatile修饰变量</p><p>*当多个线程写，那么一般情况下并发不严重的话可以用Synchronized，Synchronized并不是一开始就是重量级锁，在并发不严重的时候，比如只有一个线程访问的时候，是偏向锁；当多个线程访问，但不是同时访问，这时候锁升级为轻量级锁；当多个线程同时访问，这时候升级为重量级锁。所以在并发不是很严重的情况下，使用Synchronized是可以的。不过Synchronized有局限性，比如不能设置锁超时，不能通过代码释放锁。ReentranLock 可以通过代码释放锁，可以设置锁超时。</p><p>*高并发下，Synchronized、ReentranLock 效率低，因为同一时刻只有一个线程能进入同步代码块，如果同时有很多线程访问，那么其它线程就都在等待锁。这个时候可以使用并发包下的数据结构，例如ConcurrentHashMap，LinkBlockingQueue，以及原子性的数据结构如：AtomicInteger。</p><h3 id="悲观锁和乐观锁的区别。"><a href="#悲观锁和乐观锁的区别。" class="headerlink" title="悲观锁和乐观锁的区别。"></a>悲观锁和乐观锁的区别。</h3><p>*乐观锁：乐观锁假设多个事务之间很少发生冲突，因此在读取数据时不会加锁，而是在更新数据时检查数据的版本（如使用版本号或时间戳），如果版本匹配则执行更新操作，否则认为发生了冲突。</p><p>*悲观锁：悲观锁假设多个事务之间会频繁发生冲突，因此在读取数据时会加锁，防止其他事务对数据进行修改，直到当前事务完成操作后才释放锁。</p><h3 id="悲观锁和乐观锁使用场景的差别是什么？"><a href="#悲观锁和乐观锁使用场景的差别是什么？" class="headerlink" title="悲观锁和乐观锁使用场景的差别是什么？"></a>悲观锁和乐观锁使用场景的差别是什么？</h3><p>*乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>*悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h3 id="Java中想实现一个乐观锁，都有哪些方式？"><a href="#Java中想实现一个乐观锁，都有哪些方式？" class="headerlink" title="Java中想实现一个乐观锁，都有哪些方式？"></a>Java中想实现一个乐观锁，都有哪些方式？</h3><p>*CAS（Compare and Swap）操作： CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。</p><p>*版本号控制：增加一个版本号字段记录数据更新时候的版本，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。</p><p>*时间戳：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。</p><h3 id="使用时间戳会不会有可见性问题？"><a href="#使用时间戳会不会有可见性问题？" class="headerlink" title="使用时间戳会不会有可见性问题？"></a>使用时间戳会不会有可见性问题？</h3><p>会有可见性的问题，可见性问题指的是当一个线程修改了共享变量的值后，其他线程可能无法立即看到这个变化。</p><p>如果一个线程在读取数据的时间戳之后，另一个线程修改了数据并更新了时间戳，第一个线程可能无法感知到第二个线程的修改。这导致第一个线程在接下来的操作中基于过时的时间戳做出了错误的判断，从而可能发生数据不一致的情况。</p><p>为了避免时间戳导致的可见性问题，可以考虑使用<strong>volatile关键字</strong>： 在时间戳字段上使用 volatile 关键字可以确保多线程之间的可见性，可以及时看到其他线程对共享变量的修改。</p><h3 id="volatile能解决吗，就够了吗？"><a href="#volatile能解决吗，就够了吗？" class="headerlink" title="volatile能解决吗，就够了吗？"></a>volatile能解决吗，就够了吗？</h3><p>volatile 关键字仅仅保证了可见性，并没有提供原子性。在实现乐观锁时，如果仅仅依赖 volatile 关键字来保证时间戳的可见性，仍然可能面临以下问题：</p><p><strong>复合操作可能存在问题</strong>： 如果对时间戳字段的更新是一个复合操作，如读取时间戳、计算新值、更新时间戳，这样的操作并不具备原子性。在这种情况下，仅仅使用 volatile 是无法保证操作的原子性和线程安全的。</p><p>可以通过加锁的方式来保证对时间戳读写操作的并发安全。</p><h3 id="除了加锁还有没有别的解法，绕开加锁使性能更好？"><a href="#除了加锁还有没有别的解法，绕开加锁使性能更好？" class="headerlink" title="除了加锁还有没有别的解法，绕开加锁使性能更好？"></a>除了加锁还有没有别的解法，绕开加锁使性能更好？</h3><p>可以改用 Atomic 类来保证原子性，这些原子类是使用 CAS (Compare and Swap) 操作来保证数据的原子性。如 AtomicInteger、AtomicLong、AtomicReference 等，通过这些原子类可以实现 CAS 操作，从而确保对共享变量的原子操作。</p><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：</p><pre><code>*ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁*ReentrantLock 可以获取各种锁的信息*ReentrantLock 可以灵活地实现多路通知</code></pre><h3 id="讲一讲ThreadLocal使用的时候需要注意哪些点。"><a href="#讲一讲ThreadLocal使用的时候需要注意哪些点。" class="headerlink" title="讲一讲ThreadLocal使用的时候需要注意哪些点。"></a>讲一讲ThreadLocal使用的时候需要注意哪些点。</h3><p>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</p><pre><code>*set 给ThreadLocalMap设置值。*get 获取ThreadLocalMap。*remove 删除ThreadLocalMap类型的对象。</code></pre><p>存在的问题:</p><pre><code>1、对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。2、内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。</code></pre><p>使用完ThreadLocal后，及时调用remove()方法释放内存空间，这样就能避免内存泄漏。</p><h3 id="线程并发还有别的问题吗？"><a href="#线程并发还有别的问题吗？" class="headerlink" title="线程并发还有别的问题吗？"></a>线程并发还有别的问题吗？</h3><p>Java的线程安全在三个方面体现</p><p>*<strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic和synchronized这两个关键字来确保原子性；</p><p>*<strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</p><p>*<strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</p><h3 id="常用的线程池有哪些呢？"><a href="#常用的线程池有哪些呢？" class="headerlink" title="常用的线程池有哪些呢？"></a>常用的线程池有哪些呢？</h3><p>*ScheduledThreadPool：可以设置定期的执行任务，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。</p><p>*FixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p><p>*CachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</p><p>*SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p><p>*SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。</p><h3 id="简单讲一讲线程的生命周期"><a href="#简单讲一讲线程的生命周期" class="headerlink" title="简单讲一讲线程的生命周期"></a>简单讲一讲线程的生命周期</h3><p><img src="/assets/imgs/2024-05-14_144517.jpg" alt="ThreadPool"><br>线程池的五个状态如下</p><p>*RUNNING: 接收新的任务，并能继续处理 workQueue 中的任务</p><p>*SHUTDOWN: 不再接收新的任务，不过能继续处理 workQueue 中的任务</p><p>*STOP: 不再接收新的任务，也不再处理 workQueue 中的任务，并且会中断正在处理任务的线程</p><p>*TIDYING: 所有的任务都完结了，并且线程数量（workCount）为 0 时即为此状态，进入此状态后会调用 terminated() 这个钩子方法进入 TERMINATED 状态</p><p>*TERMINATED: 调用 terminated() 方法后即为此状态</p><h3 id="有什么办法能够提升Java线程的并发能力呢？"><a href="#有什么办法能够提升Java线程的并发能力呢？" class="headerlink" title="有什么办法能够提升Java线程的并发能力呢？"></a>有什么办法能够提升Java线程的并发能力呢？</h3><p>*<strong>使用线程池</strong>：合理配置线程池大小，避免频繁创建和销毁线程，提高线程的复用率，减少资源开销。</p><p>*<strong>使用并发集合</strong>：Java 并发包中提供了诸如 ConcurrentHashMap、ConcurrentLinkedQueue 等线程安全的集合类，使用这些并发集合可以减少在多线程环境下的锁竞争，提升并发性能</p><p>*<strong>避免锁粒度过细</strong>：过细的锁粒度会增加锁的竞争，影响并发性能，尽量使用合适的锁粒度来避免锁的争用。</p><p>*<strong>减少同步区域代码量</strong>：在同步代码块中尽量减少耗时操作，保持同步区域的代码量尽量少，以减少线程等待时间，提高并发性能。</p><p>*<strong>使用乐观锁</strong>：乐观锁机制可以提高并发性能，通过版本号或时间戳等方式，避免使用传统的悲观锁机制，减少不必要的阻塞。</p><p>*<strong>使用无锁算法</strong>：无锁的数据结构和算法可以减少锁的开销和线程之间的竞争，如CAS操作、原子类等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有哪些解决线程并发问题的方案？&quot;&gt;&lt;a href=&quot;#有哪些解决线程并发问题的方案？&quot; class=&quot;headerlink&quot; title=&quot;有哪些解决线程并发问题的方案？&quot;&gt;&lt;/a&gt;有哪些解决线程并发问题的方案？&lt;/h3&gt;&lt;p&gt;*当只有一个线程写，其它线程都是读的</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java并发" scheme="http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识点</title>
    <link href="http://example.com/2024/05/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://example.com/2024/05/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2024-05-13T07:06:15.000Z</published>
    <updated>2024-05-14T07:23:20.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM的内存区域和作用"><a href="#JVM的内存区域和作用" class="headerlink" title="JVM的内存区域和作用"></a>JVM的内存区域和作用</h3><p>JVM运行时内存共分为<strong>虚拟机栈、堆、元空间、程序计数器、本地方法栈</strong>五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><p><img src="/assets/imgs/2024-05-13_150615.jpg" alt="JVM"></p><p>JVM的内存结构主要分为以下几个部分：</p><p>*元空间：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><p>*Java虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。</p><p>*本地方法栈：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</p><p>*程序计数器：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</p><p>*堆内存：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。</p><p>*直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I&#x2F;O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h3 id="常见的GC算法有哪些？"><a href="#常见的GC算法有哪些？" class="headerlink" title="常见的GC算法有哪些？"></a>常见的GC算法有哪些？</h3><p>Java的内存回收机制基于自动内存管理，开发人员无需手动释放内存。垃圾回收器会自动识别不再使用的对象，并回收它们所占用的内存空间。垃圾回收算法主要有 ：</p><p>*标记-清除算法：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</p><p>*复制算法：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</p><p>*标记-整理算法：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</p><p>*分代回收算法：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</p><h3 id="JVM中有哪些回收器？"><a href="#JVM中有哪些回收器？" class="headerlink" title="JVM中有哪些回收器？"></a>JVM中有哪些回收器？</h3><p>*Serial 收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</p><p>*ParNew 收集器，ParNew 收集器其实就是 Serial 收集器的多线程版本。</p><p>*Parallel 收集器，Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。</p><p>*Parallel Old 收集器，Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和”标记－整理”算法</p><p>*CMS 收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>*G1 收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征</p><h3 id="G1回收器的特色是什么？"><a href="#G1回收器的特色是什么？" class="headerlink" title="G1回收器的特色是什么？"></a>G1回收器的特色是什么？</h3><p>G1 的特点：</p><pre><code>*G1最大的特点是引入分区的思路，弱化了分代的概念。*合理利用垃圾收集各个周期的资源，解决了其他收集器、甚至 CMS 的众多缺陷</code></pre><p>G1 相比较 CMS 的改进：</p><pre><code>*算法：G1 基于标记--整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。*停顿时间可控：G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。*并行与并发：G1 能更充分的利用 CPU 多核环境下的硬件优势，来缩短 stop the world 的停顿时间。</code></pre><h3 id="GC只会对堆进行GC吗？"><a href="#GC只会对堆进行GC吗？" class="headerlink" title="GC只会对堆进行GC吗？"></a>GC只会对堆进行GC吗？</h3><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p><p>*堆（Heap）： 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。<br>*方法区（Method Area）： 方法区是用于存储类信息、常量、静态变量等数据的区域。虽然方法区中的垃圾回收与堆有所不同，但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JVM的内存区域和作用&quot;&gt;&lt;a href=&quot;#JVM的内存区域和作用&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存区域和作用&quot;&gt;&lt;/a&gt;JVM的内存区域和作用&lt;/h3&gt;&lt;p&gt;JVM运行时内存共分为&lt;strong&gt;虚拟机栈、堆、元空间、程序计数</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java虚拟机" scheme="http://example.com/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
